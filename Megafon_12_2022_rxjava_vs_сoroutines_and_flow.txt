Рассмотреть 2 варианта решений в целевой версии на новой архитектуре: Rx vs Coroutines&Flows:
1. Провести сравнительный обзор АПИшек и удобства в использовании
2. Сравнить производительность
3. Особенности применения относительно нового технологического стека в многослойном приложении на чистой архитектуре
4. Тестируемость
5. Известные проблемы, если есть (сравнить)


Слайды:
 
- 2 Основные определения
Реактивное программирование — это программирование с использованием асинхронных потоков данных
При таком подходе код представляется в виде модели "Observable и Observer" (producer/consumer)
Observable - источник данных.
Observer — наблюдатель за потоком данных.
Это два фундаментальных типа, на которых основана концепция реактивного программирования.

RxJava — это фреймворк для реактивного программирования на Java.

В языке kotlin поддержка асинхронности реализована в виде корутин. Это сделано на уровне языка. По сути корутина представляет блок кода, который может выполняться параллельно с остальным кодом.

Flows сделаны на основе корутин. Корутина возвращает только одно значение. Для того чтобы вернуть последовательно несколько значений используется kotlin flows.

Картинка Rx vs Coroutines&Flow
Можно использовать только корутины если приложение не использует потоки данных (допустим просто грузит из сети и отображает их)

Кто-то пользуется фреймворком для контроля асинхронности. Кто-то считает что это слишком мощный и сложный инструмент для таких задач. И RxJava нужен в первую очередь для реактивного программирования. Помню были в сети статьи и обсуждения про это. Достаточно холиварная тема.
------->

- 3 Про корутины подробно не рассказываю, потому что отдельная большая тема (можно потом отдельно презу)

Корутины — это блоки кода, которые работают асинхронно. В нужный момент исполнение такого блока приостанавливается с сохранением всех его свойств, чтобы запустился другой код. Когда управление возвращается к первому блоку, он продолжает работу.

RxJava работает с системными потоками. В отличии от нее корутины работают поверх системных потоков. Поэтому несколько сопрограмм могут поочередно выполнять свой код на одном системном потоке.

Между корутинами и потоками нет прямого соответствия. Корутина не привязана к конкретному потоку. Она может быть приостановить выполнение в одном потоке, а возобновить выполнение в другом.

Когда корутина приостанавливает свое выполнение, например, как в случае выше при вызове задержки с помощью функции delay(), эта корутина освобождает поток, в котором она выполнялась, и сохраняется в памяти. А освобожденный поток может быть зайдествован для других задач. А когда завершается запущенная задача (например, выполнение функции delay()), корутина возобновляет свою работу в одном из свободных потоков.

Модификатор suspend определяет функцию, которая может приостановить свое выполнение и возобновить его через некоторый период времени.
Любая функция с модификатором suspend может вызываться либо из другой функции, которая тоже имеет модификатор suspend, либо из корутины.
------->

- 4 Примеры создания и запуска flow

Для создания flow также как для корутин есть билдеры (Flow builders). В примерах основные способы создания flow:
flowOf(...) функции для создания потока из фиксированного набора значений.
asFlow() функции расширения для различных типов, чтобы преобразовать их в потоки.
flow { ... } builder для создания произвольных потоков из последовательных вызовов функции emit.

у flow backpressure автоматически, не нужно об этом беспокоиться

Для выполнения flow (также как для корутины) нам надо определить для нее контекст, так как он может вызываться только в контексте корутины (coroutine scope)

Flows are cold. Асинхронный поток не запускается, пока не будет применена терминальная операция над получаемыми даными. В примере функция collect().

collect() получает из потока переданные значения
toList() преобразует поток значений в коллекцию List
toSet() преобразует поток значений в коллекцию Set
first() / firstOrNull(): получает первый объект из потока
last() / lastOrNull(): получает последний объект из потока
single() / singleOrNull(): ожидает получение одного объекта из потока
count() получает количество элементов в потоке
еще есть reduce() и fold()
------->

- 4 Сравнение API
Картинку из https://habr.com/ru/company/simbirsoft/blog/534706/ Операторы
Список часто применимых операторов

RxJava не всегда маппится 1к1 с Kotlin/Flow, но общие принципы реактивного программирования применимы к обоим технологиям.

RxJava несколько операторов для обратобки ошибок: onErrorResumeWith(), onErrorReturn(), onErrorComplete()
У Flow стандартный catch()
хорошо это или плохо? по теме работы с ошибками есть статьи на хабре

По опыту некотрых не хватает, но их не сложно реализовать (либо решения есть на stackoverflow). В Ucell нужно было реализовать свои для throtle и timer

Все здесь
https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/
------->


- 5 Flow and Reactive Streams﻿?
Концептуально Flow является реактивным потоком, и его можно преобразовать в реактивный Publisher и наоборот.

Flow совместим с реактивными потоками, может безопасно взаимодействовать с другими реактивными потоками, используя Flow.asPublisher и Publisher.asFlow из модуля kotlinx-coroutines-reactive.

Такие преобразователи предоставляются «из коробки» и могут быть найдены в соответствующих реактивных модулях (kotlinx-coroutines-reactive для Reactive Streams и kotlinx-coroutines-rx2/kotlinx-coroutines-rx3 для RxJava2/RxJava3). 
Модули интеграции включают в себя преобразования из Flow и в Flow и удобные для приостановки способы работы с различными реактивными сущностями.

Для тех, кто знаком с Reactive Streams или реактивными фреймворками, такими как RxJava, дизайн Flow может показаться очень знакомым.
Как написано в документации "Основная цель Flow — иметь как можно более простой дизайн, быть дружественным к Kotlin и suspention."
------->


- 6 Сравнить производительность
По асинхронности. Создание корутин дешевле, чем с запуск новых потоков
10000 тасков корутины - ок, rxjava - OOM

При условии активного использования асинхронности корутины снижают требования к аппаратным ресурсам устройства

Согласно тесту Reactive Scrabble, Flow работает быстрее, чем RxJava.

Reactive Scrabble — это бенчмарк для сравнения потоков, и у Kotlin есть версия бенчмарка в их репозитории. По своим показателям  Flow превосходит RxJava как в стандартных, так и в оптимизированных настройках. 
Чем ниже балл, тем лучше

https://github.com/Kotlin/kotlinx.coroutines/blob/develop/benchmarks/src/jmh/kotlin/benchmarks/flow/scrabble/README.md

- Тестируемость (слайда нет, просто сказать)
На сайте андроид есть раздел по unit тестированию flow
https://developer.android.com/kotlin/flow/test
+ Turbine lib
------->


-7  Выводы
- Jetpack и основные популярные библиотеки поддерживают корутины и Flow

- Более простой синтаксис и интуитивная интеграция с жизненным циклом Android, чем у RxJava. 
Поэтому проще отладка, легче поиск ошибок. 
При использовании RxJava нужно привязываться к жизненному циклу экрана. Иначе подписка будет висеть. Приводит к крэшам и утечкам памяти. Корутины - ViewModelScope и LifecycleScope

- coroutineScope кажется более сложным для понимания, чем disposable в RxJava

- У обеих технологий есть issues на гитхабе, но критичных препятствий для использования нет

- Минус корутин раньше заключался в том, что они не поддерживали реактив. Сейчас есть Flows, StateFlows и др. 
В основном покрывает все кейсы RxJava

- Android и Google продвигают корутины и flow в сообществе разработчиков

- Если в проекте не нужен реактивный подход, то можно использовать только корутины. 
Для трансформации коллекций в cтандартная библиотека kotlin есть функции расширения (map, filter и тд). 
В случае с RxJava придется или писать в реактивном стиле или использовать только небольшую часть фреймворка для асинхрона. Работу с потоками можно реализовать без RxJava


Flow хорошо подойдет в качестве инструмента для обработки событий в реактивном стиле в проектах на Kotlin, использующих паттерн MVVM: благодаря viewModelScope и lifecycleScope запускать корутины можно быстро и удобно, не боясь утечек. В связи с тем, что популярность Kotlin и его инструментов растет, а также этот язык является приоритетным для разработки Android-приложений, в ближайшие годы связка Coroutines+Flow может заменить RxJava – скорее всего, новые проекты будут написаны именно с помощью нее. На первый взгляд, миграция с RxJava на Flow не представляется болезненной, потому что в обоих случаях есть похожие операторы и разделение общей концепции Reactive streams. Кроме того, Kotlin имеет достаточно большое комьюнити, которое постоянно развивается и помогает разработчикам в изучении новых возможностей.


Можно удалить rxjava из проекта, тем самым сократить размер приложения


Все использованные ссылки
https://blog.skillfactory.ru/glossary/coroutine/
https://metanit.com/kotlin/tutorial/8.1.php
https://metanit.com/kotlin/tutorial/9.1.php
https://habr.com/ru/post/529944/
https://proandroiddev.com/kotlin-coroutines-flow-in-a-nutshell-90399fc9aed7
https://developer.android.com/kotlin/flow (здесь есть примеры)
https://kotlinlang.org/docs/flow.html (здесь есть примеры)
https://tech-geek.ru/kotlin-flow/
https://github.com/CRamsan/coroutine-rx-performance

--
+ Различия между корутинами и потоками https://blog.skillfactory.ru/glossary/coroutine/
+ Корутины и потоки https://metanit.com/kotlin/tutorial/8.1.php
